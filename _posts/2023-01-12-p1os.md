---
layout: post
title:  "Part 1: Writing your own operating system"
date:   2023-01-12 12:24:54 -0700
---
I've spent some time diving into operating systems and I believe my programming has benefitted from it. I think I have reached a point where I can provide some help to others who want to learn the basics of how their operating system works with the hardware, so I'm planning to write a series about it.

In this post, I'll write a short bootloader. My introduction to this topic came from the Operating Systems: from 0 to 1 book on GitHub, which provides a sample bootloader that does not work (at least on my system, with a current version of NASM). I'll do something similar to what is outlined in chapter 7.

The purpose of a bootloader is to load your operating system into memory and execute it. The bootloader is the first executable code that is loaded into RAM from the storage media that is available to your computer, such as a hard disk or floppy. Writing a bootloader for a floppy disk is slightly simpler, as we do not need to consider partitions. For more discussion of the 



Notice that the value placed in al is the number of sectors to load - you can imagine how you might increase this to load a larger operating system, rather than just the second sector. Most modern operating systems will not fit on a floppy disk, but the procedure for hard disks is similar.

Since the int instruction triggers an interrupt rather than calling a function, using "ni" to step over it will not work like it would for a function call. To step over it without getting stuck in a long interrupt routine, set a breakpoint at the following instruction.

You may notice when stepping through the code in GDB that "mov ax, 0x50" becomes something like "mov    $0xc08e0050,%eax" . (I think) that's because ax is the lower 16 bits of the 32-bit eax register, so the processor only needs to make sure that the lower 16 bits are filled with the correct number (0x0050) - this also could be because we haven't supplied GDB with any debugging information (link to Linux DWARF format).

--We can also fix this by running "set architecture i8086" within gdb, so it knows we're on a 16-bit processor (technically, we're just in 16-bit real mode on a 64 or 32 bit processor).

We've put a block of text at the beginning of the second sector so that when we examine it with a tool like hd, we'll know that it's there. The "db" command is an assembler directive, not an instruction that your processor understands - it means "define byte" (similarly, we have dw and dd for defining words and double words respectively). Conveniently, you do not need to type "db" before every character in a string: each character is converted to its ASCII representation by the assembler.

Hopefully this helped to give you a better understanding of one of the ways that your operating system interfaces with hardware, via the BIOS.

If any of the general purpose assembly instructions were confusing, you can refer to Duntemann or goober book. The former has useful discussion of memory addressing and processor modes; the latter covers more ground and has some interesting discussion of floating point coprocessor instructions.

If any of the assembly instructions confused you, I recommend referring to Jeff Duntemann's assembly programming book (3rd edition) or the Intel instruction reference (link).


Several tutorials exist for writing your own operating system, but I have not found a complete one. Since writing an OS is a big project and my goal is to understand the fundamentals, future posts will describe steps that have confused me but refer to more detailed resources such as MINIX or Windows NT for the bulk of the code. Linus took a similar approach when writing Linux: many remnants of MINIX are still visible in the source code (compare MINIX ioctls and Linux ioctls, for example)


Some other operating systems that might be useful resources:
- resource  1
helenos, tinyos from ligan, 

Citations:
- [1] [duntemann](https://google.com)


You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run `jekyll serve`, which launches a web server and auto-regenerates your site when a file is updated.

Jekyll requires blog post files to be named according to the following format:

```
YEAR-MONTH-DAY-title.MARKUP
another line
another line
```

Where `YEAR` is a four-digit number, `MONTH` and `DAY` are both two-digit numbers, and `MARKUP` is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.

Jekyll also offers powerful support for code snippets:

{% highlight ruby %}
def print_hi(name)
  puts "Hi, #{name}"
end
print_hi('Tom')
#=> prints 'Hi, Tom' to STDOUT.
{% endhighlight %}

Check out the [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll’s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
